import * as assert from "assert";
import * as path from "path";
import { isWin } from "../../shared/constants";
import { PackageMap } from "../../shared/pub/package_map";
import { writeTempFile } from "../helpers";

const data = isWin
	? {
		newFormat: `# Generated by pub on 2019-09-17 15:53:45.682066.
:my_test_new
analyzer:file:///C:/analyzer/lib/#dart=2.0
ansicolor:file:///C:/ansicolor/lib/#dart=2.0
# this would really be my_test_new but to ensure we read it from
# the top of the file in the test, we have a different name here
my_test:lib/#dart=2.0
`,
		originalFormat: `# Generated by pub on 2019-09-17 15:53:45.682066.
analyzer:file:///C:/analyzer/lib/
ansicolor:file:///C:/ansicolor/lib/
my_test:lib/
`,
		expectedPathFor(pkg: string) { return `C:\\${pkg}\\lib\\`; },
	}
	: {
		newFormat: `# Generated by pub on 2019-09-17 15:53:45.682066.
:my_test_new
analyzer:file:///analyzer/lib/#dart=2.0
ansicolor:file:///ansicolor/lib/#dart=2.0
# this would really be my_test_new but to ensure we read it from
# the top of the file in the test, we have a different name here
my_test:lib/#dart=2.0
`,
		originalFormat: `# Generated by pub on 2019-09-17 15:53:45.682066.
analyzer:file:///analyzer/lib/
ansicolor:file:///ansicolor/lib/
my_test:lib/
`,
		expectedPathFor(pkg: string) { return `/${pkg}/lib/`; },
	};

describe("PackageMap", async () => {
	it(`can parse original format`, async () => {
		const file = writeTempFile(".packages", data.originalFormat);
		const map = new PackageMap(file);

		assert.deepStrictEqual(Object.keys(map.packages), ["analyzer", "ansicolor", "my_test"]);
		assert.equal(map.localPackageName, "my_test");

		assert.equal(map.getPackagePath("analyzer"), data.expectedPathFor("analyzer"));

		const sampleFilePath = path.join(data.expectedPathFor("analyzer"), "file.dart");
		assert.equal(map.convertFileToPackageUri(sampleFilePath), "package:analyzer/file.dart");
		assert.equal(map.resolvePackageUri("package:analyzer/file.dart"), sampleFilePath);
	});

	it(`can parse original format without trailing slashes`, async () => {
		const file = writeTempFile(".packages", stripTrailingSlashes(data.originalFormat));
		const map = new PackageMap(file);

		assert.deepStrictEqual(Object.keys(map.packages), ["analyzer", "ansicolor", "my_test"]);
		assert.equal(map.localPackageName, "my_test");

		assert.equal(map.getPackagePath("analyzer"), data.expectedPathFor("analyzer"));

		const sampleFilePath = path.join(data.expectedPathFor("analyzer"), "file.dart");
		assert.equal(map.convertFileToPackageUri(sampleFilePath), "package:analyzer/file.dart");
		assert.equal(map.resolvePackageUri("package:analyzer/file.dart"), sampleFilePath);
	});

	it(`can parse new format`, async () => {
		const file = writeTempFile(".packages", data.newFormat);
		const map = new PackageMap(file);

		assert.deepStrictEqual(Object.keys(map.packages), ["analyzer", "ansicolor", "my_test"]);
		assert.equal(map.localPackageName, "my_test_new");

		assert.equal(map.getPackagePath("analyzer"), data.expectedPathFor("analyzer"));

		const sampleFilePath = path.join(data.expectedPathFor("analyzer"), "file.dart");
		assert.equal(map.convertFileToPackageUri(sampleFilePath), "package:analyzer/file.dart");
		assert.equal(map.resolvePackageUri("package:analyzer/file.dart"), sampleFilePath);
	});

	it(`can parse new format without trailing slashes`, async () => {
		const file = writeTempFile(".packages", stripTrailingSlashes(data.newFormat));
		const map = new PackageMap(file);

		assert.deepStrictEqual(Object.keys(map.packages), ["analyzer", "ansicolor", "my_test"]);
		assert.equal(map.localPackageName, "my_test_new");

		assert.equal(map.getPackagePath("analyzer"), data.expectedPathFor("analyzer"));

		const sampleFilePath = path.join(data.expectedPathFor("analyzer"), "file.dart");
		assert.equal(map.convertFileToPackageUri(sampleFilePath), "package:analyzer/file.dart");
		assert.equal(map.resolvePackageUri("package:analyzer/file.dart"), sampleFilePath);
	});
});

function stripTrailingSlashes(content: string) {
	return content.replace(/\/lib\//g, "/lib");
}
