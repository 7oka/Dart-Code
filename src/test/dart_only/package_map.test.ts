import * as assert from "assert";
import * as path from "path";
import { isWin } from "../../shared/constants";
import { PackageMap } from "../../shared/pub/package_map";
import { writeTempFile } from "../helpers";

const data = isWin
	? {
		newFormat: `# Generated by pub on 2019-09-17 15:53:45.682066.
:my_test_new
analyzer:file:///C:/analyzer/lib/#dart=2.0
analyzer_no_trail_slash:file:///C:/analyzer_no_trail_slash/lib#dart=2.0
# this would really be my_test_new but to ensure we read it from
# the top of the file in the test, we have a different name here
my_test:lib/#dart=2.0
`,
		originalFormat: `# Generated by pub on 2019-09-17 15:53:45.682066.
analyzer:file:///C:/analyzer/lib/
analyzer_no_trail_slash:file:///C:/analyzer_no_trail_slash/lib
my_test:lib/
`,
		expectedPathFor(pkg: string) { return `C:\\${pkg}\\lib\\`; },
	}
	: {
		newFormat: `# Generated by pub on 2019-09-17 15:53:45.682066.
:my_test_new
analyzer:file:///analyzer/lib/#dart=2.0
analyzer_no_trail_slash:file:///analyzer_no_trail_slash/lib#dart=2.0
# this would really be my_test_new but to ensure we read it from
# the top of the file in the test, we have a different name here
my_test:lib/#dart=2.0
`,
		originalFormat: `# Generated by pub on 2019-09-17 15:53:45.682066.
analyzer:file:///analyzer/lib/
analyzer_no_trail_slash:file:///analyzer_no_trail_slash/lib
my_test:lib/
`,
		expectedPathFor(pkg: string) { return `/${pkg}/lib/`; },
	};

describe("PackageMap", async () => {
	it(`can parse original format`, async () => {
		const file = writeTempFile(".packages", data.originalFormat);
		const map = new PackageMap(file);

		assert.deepStrictEqual(Object.keys(map.packages), ["analyzer", "analyzer_no_trail_slash", "my_test"]);
		assert.equal(map.localPackageName, "my_test");

		["analyzer", "analyzer_no_trail_slash"].forEach((pkg) => {
			assert.equal(map.getPackagePath(pkg), data.expectedPathFor(pkg));

			const sampleFilePath = path.join(data.expectedPathFor(pkg), "file.dart");
			assert.equal(map.convertFileToPackageUri(sampleFilePath), `package:${pkg}/file.dart`);
			assert.equal(map.resolvePackageUri(`package:${pkg}/file.dart`), sampleFilePath);
		});
	});

	it(`can parse new format`, async () => {
		const file = writeTempFile(".packages", data.newFormat);
		const map = new PackageMap(file);

		assert.deepStrictEqual(Object.keys(map.packages), ["analyzer", "analyzer_no_trail_slash", "my_test"]);
		assert.equal(map.localPackageName, "my_test_new");

		["analyzer", "analyzer_no_trail_slash"].forEach((pkg) => {
			assert.equal(map.getPackagePath(pkg), data.expectedPathFor(pkg));

			const sampleFilePath = path.join(data.expectedPathFor(pkg), "file.dart");
			assert.equal(map.convertFileToPackageUri(sampleFilePath), `package:${pkg}/file.dart`);
			assert.equal(map.resolvePackageUri(`package:${pkg}/file.dart`), sampleFilePath);
		});
	});
});
